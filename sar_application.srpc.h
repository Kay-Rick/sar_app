#pragma once
#include <stdio.h>
#include <string>
#include "srpc/rpc_define.h"
#include "sar_application.pb.h"

namespace SAR
{

/*
 * Server codes
 * Generated by SRPC
 */

class Service : public srpc::RPCService
{
public:
	// please implement these methods in server.cc

	virtual void SAR_Open_Interface(SAR_Open_Request *request, SAR_Open_Response *response,
					srpc::RPCContext *ctx) = 0;

	virtual void SAR_Close_Interface(SAR_Close_Request *request, SAR_Close_Response *response,
					srpc::RPCContext *ctx) = 0;

	virtual void SAR_Get_Reconstruct_Time(SAR_ReconstructTime_Request *request, SAR_ReconstructTime_Response *response,
					srpc::RPCContext *ctx) = 0;

public:
	Service();
};

/*
 * Client codes
 * Generated by SRPC
 */

using SAR_Open_InterfaceDone = std::function<void (SAR_Open_Response *, srpc::RPCContext *)>;
using SAR_Close_InterfaceDone = std::function<void (SAR_Close_Response *, srpc::RPCContext *)>;
using SAR_Get_Reconstruct_TimeDone = std::function<void (SAR_ReconstructTime_Response *, srpc::RPCContext *)>;

class SRPCClient : public srpc::SRPCClient
{
public:
	void SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_InterfaceDone done);
	void SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_Open_Response, srpc::RPCSyncContext>> async_SAR_Open_Interface(const SAR_Open_Request *req);

	void SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_InterfaceDone done);
	void SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_Close_Response, srpc::RPCSyncContext>> async_SAR_Close_Interface(const SAR_Close_Request *req);

	void SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_Get_Reconstruct_TimeDone done);
	void SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_ReconstructTime_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>> async_SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req);

public:
	SRPCClient(const char *host, unsigned short port);
	SRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::SRPCClientTask *create_SAR_Open_Interface_task(SAR_Open_InterfaceDone done);
	srpc::SRPCClientTask *create_SAR_Close_Interface_task(SAR_Close_InterfaceDone done);
	srpc::SRPCClientTask *create_SAR_Get_Reconstruct_Time_task(SAR_Get_Reconstruct_TimeDone done);
};

class SRPCHttpClient : public srpc::SRPCHttpClient
{
public:
	void SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_InterfaceDone done);
	void SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_Open_Response, srpc::RPCSyncContext>> async_SAR_Open_Interface(const SAR_Open_Request *req);

	void SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_InterfaceDone done);
	void SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_Close_Response, srpc::RPCSyncContext>> async_SAR_Close_Interface(const SAR_Close_Request *req);

	void SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_Get_Reconstruct_TimeDone done);
	void SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_ReconstructTime_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>> async_SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req);

public:
	SRPCHttpClient(const char *host, unsigned short port);
	SRPCHttpClient(const struct srpc::RPCClientParams *params);

public:
	srpc::SRPCHttpClientTask *create_SAR_Open_Interface_task(SAR_Open_InterfaceDone done);
	srpc::SRPCHttpClientTask *create_SAR_Close_Interface_task(SAR_Close_InterfaceDone done);
	srpc::SRPCHttpClientTask *create_SAR_Get_Reconstruct_Time_task(SAR_Get_Reconstruct_TimeDone done);
};

class BRPCClient : public srpc::BRPCClient
{
public:
	void SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_InterfaceDone done);
	void SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_Open_Response, srpc::RPCSyncContext>> async_SAR_Open_Interface(const SAR_Open_Request *req);

	void SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_InterfaceDone done);
	void SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_Close_Response, srpc::RPCSyncContext>> async_SAR_Close_Interface(const SAR_Close_Request *req);

	void SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_Get_Reconstruct_TimeDone done);
	void SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_ReconstructTime_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>> async_SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req);

public:
	BRPCClient(const char *host, unsigned short port);
	BRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::BRPCClientTask *create_SAR_Open_Interface_task(SAR_Open_InterfaceDone done);
	srpc::BRPCClientTask *create_SAR_Close_Interface_task(SAR_Close_InterfaceDone done);
	srpc::BRPCClientTask *create_SAR_Get_Reconstruct_Time_task(SAR_Get_Reconstruct_TimeDone done);
};

class TRPCClient : public srpc::TRPCClient
{
public:
	void SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_InterfaceDone done);
	void SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_Open_Response, srpc::RPCSyncContext>> async_SAR_Open_Interface(const SAR_Open_Request *req);

	void SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_InterfaceDone done);
	void SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_Close_Response, srpc::RPCSyncContext>> async_SAR_Close_Interface(const SAR_Close_Request *req);

	void SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_Get_Reconstruct_TimeDone done);
	void SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_ReconstructTime_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>> async_SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req);

public:
	TRPCClient(const char *host, unsigned short port);
	TRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::TRPCClientTask *create_SAR_Open_Interface_task(SAR_Open_InterfaceDone done);
	srpc::TRPCClientTask *create_SAR_Close_Interface_task(SAR_Close_InterfaceDone done);
	srpc::TRPCClientTask *create_SAR_Get_Reconstruct_Time_task(SAR_Get_Reconstruct_TimeDone done);
};

class TRPCHttpClient : public srpc::TRPCHttpClient
{
public:
	void SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_InterfaceDone done);
	void SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_Open_Response, srpc::RPCSyncContext>> async_SAR_Open_Interface(const SAR_Open_Request *req);

	void SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_InterfaceDone done);
	void SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_Close_Response, srpc::RPCSyncContext>> async_SAR_Close_Interface(const SAR_Close_Request *req);

	void SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_Get_Reconstruct_TimeDone done);
	void SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_ReconstructTime_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>> async_SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req);

public:
	TRPCHttpClient(const char *host, unsigned short port);
	TRPCHttpClient(const struct srpc::RPCClientParams *params);

public:
	srpc::TRPCHttpClientTask *create_SAR_Open_Interface_task(SAR_Open_InterfaceDone done);
	srpc::TRPCHttpClientTask *create_SAR_Close_Interface_task(SAR_Close_InterfaceDone done);
	srpc::TRPCHttpClientTask *create_SAR_Get_Reconstruct_Time_task(SAR_Get_Reconstruct_TimeDone done);
};

///// implements detials /////

inline Service::Service(): srpc::RPCService("SAR")
{
	this->srpc::RPCService::add_method("SAR_Open_Interface",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::SAR_Open_Interface);
		});

	this->srpc::RPCService::add_method("SAR_Close_Interface",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::SAR_Close_Interface);
		});

	this->srpc::RPCService::add_method("SAR_Get_Reconstruct_Time",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::SAR_Get_Reconstruct_Time);
		});
}

inline SRPCClient::SRPCClient(const char *host, unsigned short port):
	srpc::SRPCClient("SAR")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::SRPCClient::init(&params);
}

inline SRPCClient::SRPCClient(const struct srpc::RPCClientParams *params):
	srpc::SRPCClient("SAR")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::SRPCClient::init(temp);
}

inline void SRPCClient::SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Open_Interface", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Open_Interface(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_Open_Response, srpc::RPCSyncContext>> SRPCClient::async_SAR_Open_Interface(const SAR_Open_Request *req)
{
	using RESULT = std::pair<SAR_Open_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_Open_Response>("SAR_Open_Interface", srpc::RPCAsyncFutureCallback<SAR_Open_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCClient::SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Close_Interface", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Close_Interface(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_Close_Response, srpc::RPCSyncContext>> SRPCClient::async_SAR_Close_Interface(const SAR_Close_Request *req)
{
	using RESULT = std::pair<SAR_Close_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_Close_Response>("SAR_Close_Interface", srpc::RPCAsyncFutureCallback<SAR_Close_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCClient::SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_Get_Reconstruct_TimeDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Get_Reconstruct_Time", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_ReconstructTime_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Get_Reconstruct_Time(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>> SRPCClient::async_SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req)
{
	using RESULT = std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_ReconstructTime_Response>("SAR_Get_Reconstruct_Time", srpc::RPCAsyncFutureCallback<SAR_ReconstructTime_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::SRPCClientTask *SRPCClient::create_SAR_Open_Interface_task(SAR_Open_InterfaceDone done)
{
	return this->create_rpc_client_task("SAR_Open_Interface", std::move(done));
}

inline srpc::SRPCClientTask *SRPCClient::create_SAR_Close_Interface_task(SAR_Close_InterfaceDone done)
{
	return this->create_rpc_client_task("SAR_Close_Interface", std::move(done));
}

inline srpc::SRPCClientTask *SRPCClient::create_SAR_Get_Reconstruct_Time_task(SAR_Get_Reconstruct_TimeDone done)
{
	return this->create_rpc_client_task("SAR_Get_Reconstruct_Time", std::move(done));
}

inline SRPCHttpClient::SRPCHttpClient(const char *host, unsigned short port):
	srpc::SRPCHttpClient("SAR")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::SRPCHttpClient::init(&params);
}

inline SRPCHttpClient::SRPCHttpClient(const struct srpc::RPCClientParams *params):
	srpc::SRPCHttpClient("SAR")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::SRPCHttpClient::init(temp);
}

inline void SRPCHttpClient::SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Open_Interface", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Open_Interface(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_Open_Response, srpc::RPCSyncContext>> SRPCHttpClient::async_SAR_Open_Interface(const SAR_Open_Request *req)
{
	using RESULT = std::pair<SAR_Open_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_Open_Response>("SAR_Open_Interface", srpc::RPCAsyncFutureCallback<SAR_Open_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCHttpClient::SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Close_Interface", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Close_Interface(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_Close_Response, srpc::RPCSyncContext>> SRPCHttpClient::async_SAR_Close_Interface(const SAR_Close_Request *req)
{
	using RESULT = std::pair<SAR_Close_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_Close_Response>("SAR_Close_Interface", srpc::RPCAsyncFutureCallback<SAR_Close_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCHttpClient::SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_Get_Reconstruct_TimeDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Get_Reconstruct_Time", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_ReconstructTime_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Get_Reconstruct_Time(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>> SRPCHttpClient::async_SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req)
{
	using RESULT = std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_ReconstructTime_Response>("SAR_Get_Reconstruct_Time", srpc::RPCAsyncFutureCallback<SAR_ReconstructTime_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_SAR_Open_Interface_task(SAR_Open_InterfaceDone done)
{
	return this->create_rpc_client_task("SAR_Open_Interface", std::move(done));
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_SAR_Close_Interface_task(SAR_Close_InterfaceDone done)
{
	return this->create_rpc_client_task("SAR_Close_Interface", std::move(done));
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_SAR_Get_Reconstruct_Time_task(SAR_Get_Reconstruct_TimeDone done)
{
	return this->create_rpc_client_task("SAR_Get_Reconstruct_Time", std::move(done));
}

inline BRPCClient::BRPCClient(const char *host, unsigned short port):
	srpc::BRPCClient("SAR")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::BRPCClient::init(&params);
}

inline BRPCClient::BRPCClient(const struct srpc::RPCClientParams *params):
	srpc::BRPCClient("SAR")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::BRPCClient::init(temp);
}

inline void BRPCClient::SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Open_Interface", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Open_Interface(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_Open_Response, srpc::RPCSyncContext>> BRPCClient::async_SAR_Open_Interface(const SAR_Open_Request *req)
{
	using RESULT = std::pair<SAR_Open_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_Open_Response>("SAR_Open_Interface", srpc::RPCAsyncFutureCallback<SAR_Open_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void BRPCClient::SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Close_Interface", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Close_Interface(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_Close_Response, srpc::RPCSyncContext>> BRPCClient::async_SAR_Close_Interface(const SAR_Close_Request *req)
{
	using RESULT = std::pair<SAR_Close_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_Close_Response>("SAR_Close_Interface", srpc::RPCAsyncFutureCallback<SAR_Close_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void BRPCClient::SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_Get_Reconstruct_TimeDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Get_Reconstruct_Time", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_ReconstructTime_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Get_Reconstruct_Time(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>> BRPCClient::async_SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req)
{
	using RESULT = std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_ReconstructTime_Response>("SAR_Get_Reconstruct_Time", srpc::RPCAsyncFutureCallback<SAR_ReconstructTime_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::BRPCClientTask *BRPCClient::create_SAR_Open_Interface_task(SAR_Open_InterfaceDone done)
{
	return this->create_rpc_client_task("SAR_Open_Interface", std::move(done));
}

inline srpc::BRPCClientTask *BRPCClient::create_SAR_Close_Interface_task(SAR_Close_InterfaceDone done)
{
	return this->create_rpc_client_task("SAR_Close_Interface", std::move(done));
}

inline srpc::BRPCClientTask *BRPCClient::create_SAR_Get_Reconstruct_Time_task(SAR_Get_Reconstruct_TimeDone done)
{
	return this->create_rpc_client_task("SAR_Get_Reconstruct_Time", std::move(done));
}

inline TRPCClient::TRPCClient(const char *host, unsigned short port):
	srpc::TRPCClient("SAR")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::TRPCClient::init(&params);
}

inline TRPCClient::TRPCClient(const struct srpc::RPCClientParams *params):
	srpc::TRPCClient("SAR")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::TRPCClient::init(temp);
}

inline void TRPCClient::SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("/SAR/SAR_Open_Interface", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Open_Interface(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_Open_Response, srpc::RPCSyncContext>> TRPCClient::async_SAR_Open_Interface(const SAR_Open_Request *req)
{
	using RESULT = std::pair<SAR_Open_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_Open_Response>("/SAR/SAR_Open_Interface", srpc::RPCAsyncFutureCallback<SAR_Open_Response>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCClient::SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("/SAR/SAR_Close_Interface", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Close_Interface(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_Close_Response, srpc::RPCSyncContext>> TRPCClient::async_SAR_Close_Interface(const SAR_Close_Request *req)
{
	using RESULT = std::pair<SAR_Close_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_Close_Response>("/SAR/SAR_Close_Interface", srpc::RPCAsyncFutureCallback<SAR_Close_Response>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCClient::SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_Get_Reconstruct_TimeDone done)
{
	auto *task = this->create_rpc_client_task("/SAR/SAR_Get_Reconstruct_Time", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_ReconstructTime_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Get_Reconstruct_Time(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>> TRPCClient::async_SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req)
{
	using RESULT = std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_ReconstructTime_Response>("/SAR/SAR_Get_Reconstruct_Time", srpc::RPCAsyncFutureCallback<SAR_ReconstructTime_Response>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::TRPCClientTask *TRPCClient::create_SAR_Open_Interface_task(SAR_Open_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("/SAR/SAR_Open_Interface", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCClientTask *TRPCClient::create_SAR_Close_Interface_task(SAR_Close_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("/SAR/SAR_Close_Interface", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCClientTask *TRPCClient::create_SAR_Get_Reconstruct_Time_task(SAR_Get_Reconstruct_TimeDone done)
{
	auto *task = this->create_rpc_client_task("/SAR/SAR_Get_Reconstruct_Time", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline TRPCHttpClient::TRPCHttpClient(const char *host, unsigned short port):
	srpc::TRPCHttpClient("SAR")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::TRPCHttpClient::init(&params);
}

inline TRPCHttpClient::TRPCHttpClient(const struct srpc::RPCClientParams *params):
	srpc::TRPCHttpClient("SAR")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::TRPCHttpClient::init(temp);
}

inline void TRPCHttpClient::SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Open_Interface", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::SAR_Open_Interface(const SAR_Open_Request *req, SAR_Open_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Open_Interface(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_Open_Response, srpc::RPCSyncContext>> TRPCHttpClient::async_SAR_Open_Interface(const SAR_Open_Request *req)
{
	using RESULT = std::pair<SAR_Open_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_Open_Response>("SAR_Open_Interface", srpc::RPCAsyncFutureCallback<SAR_Open_Response>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCHttpClient::SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Close_Interface", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::SAR_Close_Interface(const SAR_Close_Request *req, SAR_Close_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Close_Interface(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_Close_Response, srpc::RPCSyncContext>> TRPCHttpClient::async_SAR_Close_Interface(const SAR_Close_Request *req)
{
	using RESULT = std::pair<SAR_Close_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_Close_Response>("SAR_Close_Interface", srpc::RPCAsyncFutureCallback<SAR_Close_Response>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCHttpClient::SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_Get_Reconstruct_TimeDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Get_Reconstruct_Time", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req, SAR_ReconstructTime_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SAR_Get_Reconstruct_Time(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>> TRPCHttpClient::async_SAR_Get_Reconstruct_Time(const SAR_ReconstructTime_Request *req)
{
	using RESULT = std::pair<SAR_ReconstructTime_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<SAR_ReconstructTime_Response>("SAR_Get_Reconstruct_Time", srpc::RPCAsyncFutureCallback<SAR_ReconstructTime_Response>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_SAR_Open_Interface_task(SAR_Open_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Open_Interface", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_SAR_Close_Interface_task(SAR_Close_InterfaceDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Close_Interface", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_SAR_Get_Reconstruct_Time_task(SAR_Get_Reconstruct_TimeDone done)
{
	auto *task = this->create_rpc_client_task("SAR_Get_Reconstruct_Time", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

} // end namespace SAR


namespace DSPController
{

/*
 * Server codes
 * Generated by SRPC
 */

class Service : public srpc::RPCService
{
public:
	// please implement these methods in server.cc

	virtual void LoadSarApp(DSPControllerRequest *request, DSPControllerResponse *response,
					srpc::RPCContext *ctx) = 0;

	virtual void StartSarApp(DSPControllerRequest *request, DSPControllerResponse *response,
					srpc::RPCContext *ctx) = 0;

	virtual void StopSarApp(DSPControllerRequest *request, DSPControllerResponse *response,
					srpc::RPCContext *ctx) = 0;

	virtual void SwitchSarApp(DSPControllerRequest *request, DSPControllerResponse *response,
					srpc::RPCContext *ctx) = 0;

	virtual void GetSarReconstructTime(DSPControllerRequest *request, ReconstructTimeResponse *response,
					srpc::RPCContext *ctx) = 0;

public:
	Service();
};

/*
 * Client codes
 * Generated by SRPC
 */

using LoadSarAppDone = std::function<void (DSPControllerResponse *, srpc::RPCContext *)>;
using StartSarAppDone = std::function<void (DSPControllerResponse *, srpc::RPCContext *)>;
using StopSarAppDone = std::function<void (DSPControllerResponse *, srpc::RPCContext *)>;
using SwitchSarAppDone = std::function<void (DSPControllerResponse *, srpc::RPCContext *)>;
using GetSarReconstructTimeDone = std::function<void (ReconstructTimeResponse *, srpc::RPCContext *)>;

class SRPCClient : public srpc::SRPCClient
{
public:
	void LoadSarApp(const DSPControllerRequest *req, LoadSarAppDone done);
	void LoadSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_LoadSarApp(const DSPControllerRequest *req);

	void StartSarApp(const DSPControllerRequest *req, StartSarAppDone done);
	void StartSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_StartSarApp(const DSPControllerRequest *req);

	void StopSarApp(const DSPControllerRequest *req, StopSarAppDone done);
	void StopSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_StopSarApp(const DSPControllerRequest *req);

	void SwitchSarApp(const DSPControllerRequest *req, SwitchSarAppDone done);
	void SwitchSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_SwitchSarApp(const DSPControllerRequest *req);

	void GetSarReconstructTime(const DSPControllerRequest *req, GetSarReconstructTimeDone done);
	void GetSarReconstructTime(const DSPControllerRequest *req, ReconstructTimeResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>> async_GetSarReconstructTime(const DSPControllerRequest *req);

public:
	SRPCClient(const char *host, unsigned short port);
	SRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::SRPCClientTask *create_LoadSarApp_task(LoadSarAppDone done);
	srpc::SRPCClientTask *create_StartSarApp_task(StartSarAppDone done);
	srpc::SRPCClientTask *create_StopSarApp_task(StopSarAppDone done);
	srpc::SRPCClientTask *create_SwitchSarApp_task(SwitchSarAppDone done);
	srpc::SRPCClientTask *create_GetSarReconstructTime_task(GetSarReconstructTimeDone done);
};

class SRPCHttpClient : public srpc::SRPCHttpClient
{
public:
	void LoadSarApp(const DSPControllerRequest *req, LoadSarAppDone done);
	void LoadSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_LoadSarApp(const DSPControllerRequest *req);

	void StartSarApp(const DSPControllerRequest *req, StartSarAppDone done);
	void StartSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_StartSarApp(const DSPControllerRequest *req);

	void StopSarApp(const DSPControllerRequest *req, StopSarAppDone done);
	void StopSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_StopSarApp(const DSPControllerRequest *req);

	void SwitchSarApp(const DSPControllerRequest *req, SwitchSarAppDone done);
	void SwitchSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_SwitchSarApp(const DSPControllerRequest *req);

	void GetSarReconstructTime(const DSPControllerRequest *req, GetSarReconstructTimeDone done);
	void GetSarReconstructTime(const DSPControllerRequest *req, ReconstructTimeResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>> async_GetSarReconstructTime(const DSPControllerRequest *req);

public:
	SRPCHttpClient(const char *host, unsigned short port);
	SRPCHttpClient(const struct srpc::RPCClientParams *params);

public:
	srpc::SRPCHttpClientTask *create_LoadSarApp_task(LoadSarAppDone done);
	srpc::SRPCHttpClientTask *create_StartSarApp_task(StartSarAppDone done);
	srpc::SRPCHttpClientTask *create_StopSarApp_task(StopSarAppDone done);
	srpc::SRPCHttpClientTask *create_SwitchSarApp_task(SwitchSarAppDone done);
	srpc::SRPCHttpClientTask *create_GetSarReconstructTime_task(GetSarReconstructTimeDone done);
};

class BRPCClient : public srpc::BRPCClient
{
public:
	void LoadSarApp(const DSPControllerRequest *req, LoadSarAppDone done);
	void LoadSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_LoadSarApp(const DSPControllerRequest *req);

	void StartSarApp(const DSPControllerRequest *req, StartSarAppDone done);
	void StartSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_StartSarApp(const DSPControllerRequest *req);

	void StopSarApp(const DSPControllerRequest *req, StopSarAppDone done);
	void StopSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_StopSarApp(const DSPControllerRequest *req);

	void SwitchSarApp(const DSPControllerRequest *req, SwitchSarAppDone done);
	void SwitchSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_SwitchSarApp(const DSPControllerRequest *req);

	void GetSarReconstructTime(const DSPControllerRequest *req, GetSarReconstructTimeDone done);
	void GetSarReconstructTime(const DSPControllerRequest *req, ReconstructTimeResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>> async_GetSarReconstructTime(const DSPControllerRequest *req);

public:
	BRPCClient(const char *host, unsigned short port);
	BRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::BRPCClientTask *create_LoadSarApp_task(LoadSarAppDone done);
	srpc::BRPCClientTask *create_StartSarApp_task(StartSarAppDone done);
	srpc::BRPCClientTask *create_StopSarApp_task(StopSarAppDone done);
	srpc::BRPCClientTask *create_SwitchSarApp_task(SwitchSarAppDone done);
	srpc::BRPCClientTask *create_GetSarReconstructTime_task(GetSarReconstructTimeDone done);
};

class TRPCClient : public srpc::TRPCClient
{
public:
	void LoadSarApp(const DSPControllerRequest *req, LoadSarAppDone done);
	void LoadSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_LoadSarApp(const DSPControllerRequest *req);

	void StartSarApp(const DSPControllerRequest *req, StartSarAppDone done);
	void StartSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_StartSarApp(const DSPControllerRequest *req);

	void StopSarApp(const DSPControllerRequest *req, StopSarAppDone done);
	void StopSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_StopSarApp(const DSPControllerRequest *req);

	void SwitchSarApp(const DSPControllerRequest *req, SwitchSarAppDone done);
	void SwitchSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_SwitchSarApp(const DSPControllerRequest *req);

	void GetSarReconstructTime(const DSPControllerRequest *req, GetSarReconstructTimeDone done);
	void GetSarReconstructTime(const DSPControllerRequest *req, ReconstructTimeResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>> async_GetSarReconstructTime(const DSPControllerRequest *req);

public:
	TRPCClient(const char *host, unsigned short port);
	TRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::TRPCClientTask *create_LoadSarApp_task(LoadSarAppDone done);
	srpc::TRPCClientTask *create_StartSarApp_task(StartSarAppDone done);
	srpc::TRPCClientTask *create_StopSarApp_task(StopSarAppDone done);
	srpc::TRPCClientTask *create_SwitchSarApp_task(SwitchSarAppDone done);
	srpc::TRPCClientTask *create_GetSarReconstructTime_task(GetSarReconstructTimeDone done);
};

class TRPCHttpClient : public srpc::TRPCHttpClient
{
public:
	void LoadSarApp(const DSPControllerRequest *req, LoadSarAppDone done);
	void LoadSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_LoadSarApp(const DSPControllerRequest *req);

	void StartSarApp(const DSPControllerRequest *req, StartSarAppDone done);
	void StartSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_StartSarApp(const DSPControllerRequest *req);

	void StopSarApp(const DSPControllerRequest *req, StopSarAppDone done);
	void StopSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_StopSarApp(const DSPControllerRequest *req);

	void SwitchSarApp(const DSPControllerRequest *req, SwitchSarAppDone done);
	void SwitchSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> async_SwitchSarApp(const DSPControllerRequest *req);

	void GetSarReconstructTime(const DSPControllerRequest *req, GetSarReconstructTimeDone done);
	void GetSarReconstructTime(const DSPControllerRequest *req, ReconstructTimeResponse *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>> async_GetSarReconstructTime(const DSPControllerRequest *req);

public:
	TRPCHttpClient(const char *host, unsigned short port);
	TRPCHttpClient(const struct srpc::RPCClientParams *params);

public:
	srpc::TRPCHttpClientTask *create_LoadSarApp_task(LoadSarAppDone done);
	srpc::TRPCHttpClientTask *create_StartSarApp_task(StartSarAppDone done);
	srpc::TRPCHttpClientTask *create_StopSarApp_task(StopSarAppDone done);
	srpc::TRPCHttpClientTask *create_SwitchSarApp_task(SwitchSarAppDone done);
	srpc::TRPCHttpClientTask *create_GetSarReconstructTime_task(GetSarReconstructTimeDone done);
};

///// implements detials /////

inline Service::Service(): srpc::RPCService("DSPController")
{
	this->srpc::RPCService::add_method("LoadSarApp",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::LoadSarApp);
		});

	this->srpc::RPCService::add_method("StartSarApp",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::StartSarApp);
		});

	this->srpc::RPCService::add_method("StopSarApp",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::StopSarApp);
		});

	this->srpc::RPCService::add_method("SwitchSarApp",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::SwitchSarApp);
		});

	this->srpc::RPCService::add_method("GetSarReconstructTime",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::GetSarReconstructTime);
		});
}

inline SRPCClient::SRPCClient(const char *host, unsigned short port):
	srpc::SRPCClient("DSPController")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::SRPCClient::init(&params);
}

inline SRPCClient::SRPCClient(const struct srpc::RPCClientParams *params):
	srpc::SRPCClient("DSPController")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::SRPCClient::init(temp);
}

inline void SRPCClient::LoadSarApp(const DSPControllerRequest *req, LoadSarAppDone done)
{
	auto *task = this->create_rpc_client_task("LoadSarApp", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::LoadSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_LoadSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> SRPCClient::async_LoadSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("LoadSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCClient::StartSarApp(const DSPControllerRequest *req, StartSarAppDone done)
{
	auto *task = this->create_rpc_client_task("StartSarApp", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::StartSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_StartSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> SRPCClient::async_StartSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("StartSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCClient::StopSarApp(const DSPControllerRequest *req, StopSarAppDone done)
{
	auto *task = this->create_rpc_client_task("StopSarApp", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::StopSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_StopSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> SRPCClient::async_StopSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("StopSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCClient::SwitchSarApp(const DSPControllerRequest *req, SwitchSarAppDone done)
{
	auto *task = this->create_rpc_client_task("SwitchSarApp", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::SwitchSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SwitchSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> SRPCClient::async_SwitchSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("SwitchSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCClient::GetSarReconstructTime(const DSPControllerRequest *req, GetSarReconstructTimeDone done)
{
	auto *task = this->create_rpc_client_task("GetSarReconstructTime", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::GetSarReconstructTime(const DSPControllerRequest *req, ReconstructTimeResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_GetSarReconstructTime(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>> SRPCClient::async_GetSarReconstructTime(const DSPControllerRequest *req)
{
	using RESULT = std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<ReconstructTimeResponse>("GetSarReconstructTime", srpc::RPCAsyncFutureCallback<ReconstructTimeResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::SRPCClientTask *SRPCClient::create_LoadSarApp_task(LoadSarAppDone done)
{
	return this->create_rpc_client_task("LoadSarApp", std::move(done));
}

inline srpc::SRPCClientTask *SRPCClient::create_StartSarApp_task(StartSarAppDone done)
{
	return this->create_rpc_client_task("StartSarApp", std::move(done));
}

inline srpc::SRPCClientTask *SRPCClient::create_StopSarApp_task(StopSarAppDone done)
{
	return this->create_rpc_client_task("StopSarApp", std::move(done));
}

inline srpc::SRPCClientTask *SRPCClient::create_SwitchSarApp_task(SwitchSarAppDone done)
{
	return this->create_rpc_client_task("SwitchSarApp", std::move(done));
}

inline srpc::SRPCClientTask *SRPCClient::create_GetSarReconstructTime_task(GetSarReconstructTimeDone done)
{
	return this->create_rpc_client_task("GetSarReconstructTime", std::move(done));
}

inline SRPCHttpClient::SRPCHttpClient(const char *host, unsigned short port):
	srpc::SRPCHttpClient("DSPController")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::SRPCHttpClient::init(&params);
}

inline SRPCHttpClient::SRPCHttpClient(const struct srpc::RPCClientParams *params):
	srpc::SRPCHttpClient("DSPController")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::SRPCHttpClient::init(temp);
}

inline void SRPCHttpClient::LoadSarApp(const DSPControllerRequest *req, LoadSarAppDone done)
{
	auto *task = this->create_rpc_client_task("LoadSarApp", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::LoadSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_LoadSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> SRPCHttpClient::async_LoadSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("LoadSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCHttpClient::StartSarApp(const DSPControllerRequest *req, StartSarAppDone done)
{
	auto *task = this->create_rpc_client_task("StartSarApp", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::StartSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_StartSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> SRPCHttpClient::async_StartSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("StartSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCHttpClient::StopSarApp(const DSPControllerRequest *req, StopSarAppDone done)
{
	auto *task = this->create_rpc_client_task("StopSarApp", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::StopSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_StopSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> SRPCHttpClient::async_StopSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("StopSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCHttpClient::SwitchSarApp(const DSPControllerRequest *req, SwitchSarAppDone done)
{
	auto *task = this->create_rpc_client_task("SwitchSarApp", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::SwitchSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SwitchSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> SRPCHttpClient::async_SwitchSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("SwitchSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCHttpClient::GetSarReconstructTime(const DSPControllerRequest *req, GetSarReconstructTimeDone done)
{
	auto *task = this->create_rpc_client_task("GetSarReconstructTime", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::GetSarReconstructTime(const DSPControllerRequest *req, ReconstructTimeResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_GetSarReconstructTime(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>> SRPCHttpClient::async_GetSarReconstructTime(const DSPControllerRequest *req)
{
	using RESULT = std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<ReconstructTimeResponse>("GetSarReconstructTime", srpc::RPCAsyncFutureCallback<ReconstructTimeResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_LoadSarApp_task(LoadSarAppDone done)
{
	return this->create_rpc_client_task("LoadSarApp", std::move(done));
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_StartSarApp_task(StartSarAppDone done)
{
	return this->create_rpc_client_task("StartSarApp", std::move(done));
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_StopSarApp_task(StopSarAppDone done)
{
	return this->create_rpc_client_task("StopSarApp", std::move(done));
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_SwitchSarApp_task(SwitchSarAppDone done)
{
	return this->create_rpc_client_task("SwitchSarApp", std::move(done));
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_GetSarReconstructTime_task(GetSarReconstructTimeDone done)
{
	return this->create_rpc_client_task("GetSarReconstructTime", std::move(done));
}

inline BRPCClient::BRPCClient(const char *host, unsigned short port):
	srpc::BRPCClient("DSPController")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::BRPCClient::init(&params);
}

inline BRPCClient::BRPCClient(const struct srpc::RPCClientParams *params):
	srpc::BRPCClient("DSPController")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::BRPCClient::init(temp);
}

inline void BRPCClient::LoadSarApp(const DSPControllerRequest *req, LoadSarAppDone done)
{
	auto *task = this->create_rpc_client_task("LoadSarApp", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::LoadSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_LoadSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> BRPCClient::async_LoadSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("LoadSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void BRPCClient::StartSarApp(const DSPControllerRequest *req, StartSarAppDone done)
{
	auto *task = this->create_rpc_client_task("StartSarApp", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::StartSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_StartSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> BRPCClient::async_StartSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("StartSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void BRPCClient::StopSarApp(const DSPControllerRequest *req, StopSarAppDone done)
{
	auto *task = this->create_rpc_client_task("StopSarApp", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::StopSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_StopSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> BRPCClient::async_StopSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("StopSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void BRPCClient::SwitchSarApp(const DSPControllerRequest *req, SwitchSarAppDone done)
{
	auto *task = this->create_rpc_client_task("SwitchSarApp", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::SwitchSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SwitchSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> BRPCClient::async_SwitchSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("SwitchSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void BRPCClient::GetSarReconstructTime(const DSPControllerRequest *req, GetSarReconstructTimeDone done)
{
	auto *task = this->create_rpc_client_task("GetSarReconstructTime", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::GetSarReconstructTime(const DSPControllerRequest *req, ReconstructTimeResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_GetSarReconstructTime(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>> BRPCClient::async_GetSarReconstructTime(const DSPControllerRequest *req)
{
	using RESULT = std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<ReconstructTimeResponse>("GetSarReconstructTime", srpc::RPCAsyncFutureCallback<ReconstructTimeResponse>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::BRPCClientTask *BRPCClient::create_LoadSarApp_task(LoadSarAppDone done)
{
	return this->create_rpc_client_task("LoadSarApp", std::move(done));
}

inline srpc::BRPCClientTask *BRPCClient::create_StartSarApp_task(StartSarAppDone done)
{
	return this->create_rpc_client_task("StartSarApp", std::move(done));
}

inline srpc::BRPCClientTask *BRPCClient::create_StopSarApp_task(StopSarAppDone done)
{
	return this->create_rpc_client_task("StopSarApp", std::move(done));
}

inline srpc::BRPCClientTask *BRPCClient::create_SwitchSarApp_task(SwitchSarAppDone done)
{
	return this->create_rpc_client_task("SwitchSarApp", std::move(done));
}

inline srpc::BRPCClientTask *BRPCClient::create_GetSarReconstructTime_task(GetSarReconstructTimeDone done)
{
	return this->create_rpc_client_task("GetSarReconstructTime", std::move(done));
}

inline TRPCClient::TRPCClient(const char *host, unsigned short port):
	srpc::TRPCClient("DSPController")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::TRPCClient::init(&params);
}

inline TRPCClient::TRPCClient(const struct srpc::RPCClientParams *params):
	srpc::TRPCClient("DSPController")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::TRPCClient::init(temp);
}

inline void TRPCClient::LoadSarApp(const DSPControllerRequest *req, LoadSarAppDone done)
{
	auto *task = this->create_rpc_client_task("/DSPController/LoadSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::LoadSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_LoadSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> TRPCClient::async_LoadSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("/DSPController/LoadSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCClient::StartSarApp(const DSPControllerRequest *req, StartSarAppDone done)
{
	auto *task = this->create_rpc_client_task("/DSPController/StartSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::StartSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_StartSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> TRPCClient::async_StartSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("/DSPController/StartSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCClient::StopSarApp(const DSPControllerRequest *req, StopSarAppDone done)
{
	auto *task = this->create_rpc_client_task("/DSPController/StopSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::StopSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_StopSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> TRPCClient::async_StopSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("/DSPController/StopSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCClient::SwitchSarApp(const DSPControllerRequest *req, SwitchSarAppDone done)
{
	auto *task = this->create_rpc_client_task("/DSPController/SwitchSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::SwitchSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SwitchSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> TRPCClient::async_SwitchSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("/DSPController/SwitchSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCClient::GetSarReconstructTime(const DSPControllerRequest *req, GetSarReconstructTimeDone done)
{
	auto *task = this->create_rpc_client_task("/DSPController/GetSarReconstructTime", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::GetSarReconstructTime(const DSPControllerRequest *req, ReconstructTimeResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_GetSarReconstructTime(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>> TRPCClient::async_GetSarReconstructTime(const DSPControllerRequest *req)
{
	using RESULT = std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<ReconstructTimeResponse>("/DSPController/GetSarReconstructTime", srpc::RPCAsyncFutureCallback<ReconstructTimeResponse>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::TRPCClientTask *TRPCClient::create_LoadSarApp_task(LoadSarAppDone done)
{
	auto *task = this->create_rpc_client_task("/DSPController/LoadSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCClientTask *TRPCClient::create_StartSarApp_task(StartSarAppDone done)
{
	auto *task = this->create_rpc_client_task("/DSPController/StartSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCClientTask *TRPCClient::create_StopSarApp_task(StopSarAppDone done)
{
	auto *task = this->create_rpc_client_task("/DSPController/StopSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCClientTask *TRPCClient::create_SwitchSarApp_task(SwitchSarAppDone done)
{
	auto *task = this->create_rpc_client_task("/DSPController/SwitchSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCClientTask *TRPCClient::create_GetSarReconstructTime_task(GetSarReconstructTimeDone done)
{
	auto *task = this->create_rpc_client_task("/DSPController/GetSarReconstructTime", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline TRPCHttpClient::TRPCHttpClient(const char *host, unsigned short port):
	srpc::TRPCHttpClient("DSPController")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::TRPCHttpClient::init(&params);
}

inline TRPCHttpClient::TRPCHttpClient(const struct srpc::RPCClientParams *params):
	srpc::TRPCHttpClient("DSPController")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::TRPCHttpClient::init(temp);
}

inline void TRPCHttpClient::LoadSarApp(const DSPControllerRequest *req, LoadSarAppDone done)
{
	auto *task = this->create_rpc_client_task("LoadSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::LoadSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_LoadSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> TRPCHttpClient::async_LoadSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("LoadSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCHttpClient::StartSarApp(const DSPControllerRequest *req, StartSarAppDone done)
{
	auto *task = this->create_rpc_client_task("StartSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::StartSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_StartSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> TRPCHttpClient::async_StartSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("StartSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCHttpClient::StopSarApp(const DSPControllerRequest *req, StopSarAppDone done)
{
	auto *task = this->create_rpc_client_task("StopSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::StopSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_StopSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> TRPCHttpClient::async_StopSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("StopSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCHttpClient::SwitchSarApp(const DSPControllerRequest *req, SwitchSarAppDone done)
{
	auto *task = this->create_rpc_client_task("SwitchSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::SwitchSarApp(const DSPControllerRequest *req, DSPControllerResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_SwitchSarApp(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<DSPControllerResponse, srpc::RPCSyncContext>> TRPCHttpClient::async_SwitchSarApp(const DSPControllerRequest *req)
{
	using RESULT = std::pair<DSPControllerResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<DSPControllerResponse>("SwitchSarApp", srpc::RPCAsyncFutureCallback<DSPControllerResponse>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCHttpClient::GetSarReconstructTime(const DSPControllerRequest *req, GetSarReconstructTimeDone done)
{
	auto *task = this->create_rpc_client_task("GetSarReconstructTime", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::GetSarReconstructTime(const DSPControllerRequest *req, ReconstructTimeResponse *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_GetSarReconstructTime(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>> TRPCHttpClient::async_GetSarReconstructTime(const DSPControllerRequest *req)
{
	using RESULT = std::pair<ReconstructTimeResponse, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<ReconstructTimeResponse>("GetSarReconstructTime", srpc::RPCAsyncFutureCallback<ReconstructTimeResponse>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_LoadSarApp_task(LoadSarAppDone done)
{
	auto *task = this->create_rpc_client_task("LoadSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_StartSarApp_task(StartSarAppDone done)
{
	auto *task = this->create_rpc_client_task("StartSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_StopSarApp_task(StopSarAppDone done)
{
	auto *task = this->create_rpc_client_task("StopSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_SwitchSarApp_task(SwitchSarAppDone done)
{
	auto *task = this->create_rpc_client_task("SwitchSarApp", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_GetSarReconstructTime_task(GetSarReconstructTimeDone done)
{
	auto *task = this->create_rpc_client_task("GetSarReconstructTime", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

} // end namespace DSPController


namespace SAR_iamge_processing_service
{

/*
 * Server codes
 * Generated by SRPC
 */

class Service : public srpc::RPCService
{
public:
	// please implement these methods in server.cc

	virtual void noise_reduction(NoiseReduction_Request *request, NoiseReduction_Response *response,
					srpc::RPCContext *ctx) = 0;

	virtual void feature_etraction(Feature_Etraction_Request *request, Feature_Etraction_Response *response,
					srpc::RPCContext *ctx) = 0;

public:
	Service();
};

/*
 * Client codes
 * Generated by SRPC
 */

using noise_reductionDone = std::function<void (NoiseReduction_Response *, srpc::RPCContext *)>;
using feature_etractionDone = std::function<void (Feature_Etraction_Response *, srpc::RPCContext *)>;

class SRPCClient : public srpc::SRPCClient
{
public:
	void noise_reduction(const NoiseReduction_Request *req, noise_reductionDone done);
	void noise_reduction(const NoiseReduction_Request *req, NoiseReduction_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<NoiseReduction_Response, srpc::RPCSyncContext>> async_noise_reduction(const NoiseReduction_Request *req);

	void feature_etraction(const Feature_Etraction_Request *req, feature_etractionDone done);
	void feature_etraction(const Feature_Etraction_Request *req, Feature_Etraction_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>> async_feature_etraction(const Feature_Etraction_Request *req);

public:
	SRPCClient(const char *host, unsigned short port);
	SRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::SRPCClientTask *create_noise_reduction_task(noise_reductionDone done);
	srpc::SRPCClientTask *create_feature_etraction_task(feature_etractionDone done);
};

class SRPCHttpClient : public srpc::SRPCHttpClient
{
public:
	void noise_reduction(const NoiseReduction_Request *req, noise_reductionDone done);
	void noise_reduction(const NoiseReduction_Request *req, NoiseReduction_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<NoiseReduction_Response, srpc::RPCSyncContext>> async_noise_reduction(const NoiseReduction_Request *req);

	void feature_etraction(const Feature_Etraction_Request *req, feature_etractionDone done);
	void feature_etraction(const Feature_Etraction_Request *req, Feature_Etraction_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>> async_feature_etraction(const Feature_Etraction_Request *req);

public:
	SRPCHttpClient(const char *host, unsigned short port);
	SRPCHttpClient(const struct srpc::RPCClientParams *params);

public:
	srpc::SRPCHttpClientTask *create_noise_reduction_task(noise_reductionDone done);
	srpc::SRPCHttpClientTask *create_feature_etraction_task(feature_etractionDone done);
};

class BRPCClient : public srpc::BRPCClient
{
public:
	void noise_reduction(const NoiseReduction_Request *req, noise_reductionDone done);
	void noise_reduction(const NoiseReduction_Request *req, NoiseReduction_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<NoiseReduction_Response, srpc::RPCSyncContext>> async_noise_reduction(const NoiseReduction_Request *req);

	void feature_etraction(const Feature_Etraction_Request *req, feature_etractionDone done);
	void feature_etraction(const Feature_Etraction_Request *req, Feature_Etraction_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>> async_feature_etraction(const Feature_Etraction_Request *req);

public:
	BRPCClient(const char *host, unsigned short port);
	BRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::BRPCClientTask *create_noise_reduction_task(noise_reductionDone done);
	srpc::BRPCClientTask *create_feature_etraction_task(feature_etractionDone done);
};

class TRPCClient : public srpc::TRPCClient
{
public:
	void noise_reduction(const NoiseReduction_Request *req, noise_reductionDone done);
	void noise_reduction(const NoiseReduction_Request *req, NoiseReduction_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<NoiseReduction_Response, srpc::RPCSyncContext>> async_noise_reduction(const NoiseReduction_Request *req);

	void feature_etraction(const Feature_Etraction_Request *req, feature_etractionDone done);
	void feature_etraction(const Feature_Etraction_Request *req, Feature_Etraction_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>> async_feature_etraction(const Feature_Etraction_Request *req);

public:
	TRPCClient(const char *host, unsigned short port);
	TRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::TRPCClientTask *create_noise_reduction_task(noise_reductionDone done);
	srpc::TRPCClientTask *create_feature_etraction_task(feature_etractionDone done);
};

class TRPCHttpClient : public srpc::TRPCHttpClient
{
public:
	void noise_reduction(const NoiseReduction_Request *req, noise_reductionDone done);
	void noise_reduction(const NoiseReduction_Request *req, NoiseReduction_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<NoiseReduction_Response, srpc::RPCSyncContext>> async_noise_reduction(const NoiseReduction_Request *req);

	void feature_etraction(const Feature_Etraction_Request *req, feature_etractionDone done);
	void feature_etraction(const Feature_Etraction_Request *req, Feature_Etraction_Response *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>> async_feature_etraction(const Feature_Etraction_Request *req);

public:
	TRPCHttpClient(const char *host, unsigned short port);
	TRPCHttpClient(const struct srpc::RPCClientParams *params);

public:
	srpc::TRPCHttpClientTask *create_noise_reduction_task(noise_reductionDone done);
	srpc::TRPCHttpClientTask *create_feature_etraction_task(feature_etractionDone done);
};

///// implements detials /////

inline Service::Service(): srpc::RPCService("SAR_iamge_processing_service")
{
	this->srpc::RPCService::add_method("noise_reduction",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::noise_reduction);
		});

	this->srpc::RPCService::add_method("feature_etraction",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::feature_etraction);
		});
}

inline SRPCClient::SRPCClient(const char *host, unsigned short port):
	srpc::SRPCClient("SAR_iamge_processing_service")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::SRPCClient::init(&params);
}

inline SRPCClient::SRPCClient(const struct srpc::RPCClientParams *params):
	srpc::SRPCClient("SAR_iamge_processing_service")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::SRPCClient::init(temp);
}

inline void SRPCClient::noise_reduction(const NoiseReduction_Request *req, noise_reductionDone done)
{
	auto *task = this->create_rpc_client_task("noise_reduction", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::noise_reduction(const NoiseReduction_Request *req, NoiseReduction_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_noise_reduction(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<NoiseReduction_Response, srpc::RPCSyncContext>> SRPCClient::async_noise_reduction(const NoiseReduction_Request *req)
{
	using RESULT = std::pair<NoiseReduction_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<NoiseReduction_Response>("noise_reduction", srpc::RPCAsyncFutureCallback<NoiseReduction_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCClient::feature_etraction(const Feature_Etraction_Request *req, feature_etractionDone done)
{
	auto *task = this->create_rpc_client_task("feature_etraction", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::feature_etraction(const Feature_Etraction_Request *req, Feature_Etraction_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_feature_etraction(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>> SRPCClient::async_feature_etraction(const Feature_Etraction_Request *req)
{
	using RESULT = std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<Feature_Etraction_Response>("feature_etraction", srpc::RPCAsyncFutureCallback<Feature_Etraction_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::SRPCClientTask *SRPCClient::create_noise_reduction_task(noise_reductionDone done)
{
	return this->create_rpc_client_task("noise_reduction", std::move(done));
}

inline srpc::SRPCClientTask *SRPCClient::create_feature_etraction_task(feature_etractionDone done)
{
	return this->create_rpc_client_task("feature_etraction", std::move(done));
}

inline SRPCHttpClient::SRPCHttpClient(const char *host, unsigned short port):
	srpc::SRPCHttpClient("SAR_iamge_processing_service")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::SRPCHttpClient::init(&params);
}

inline SRPCHttpClient::SRPCHttpClient(const struct srpc::RPCClientParams *params):
	srpc::SRPCHttpClient("SAR_iamge_processing_service")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::SRPCHttpClient::init(temp);
}

inline void SRPCHttpClient::noise_reduction(const NoiseReduction_Request *req, noise_reductionDone done)
{
	auto *task = this->create_rpc_client_task("noise_reduction", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::noise_reduction(const NoiseReduction_Request *req, NoiseReduction_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_noise_reduction(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<NoiseReduction_Response, srpc::RPCSyncContext>> SRPCHttpClient::async_noise_reduction(const NoiseReduction_Request *req)
{
	using RESULT = std::pair<NoiseReduction_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<NoiseReduction_Response>("noise_reduction", srpc::RPCAsyncFutureCallback<NoiseReduction_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void SRPCHttpClient::feature_etraction(const Feature_Etraction_Request *req, feature_etractionDone done)
{
	auto *task = this->create_rpc_client_task("feature_etraction", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::feature_etraction(const Feature_Etraction_Request *req, Feature_Etraction_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_feature_etraction(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>> SRPCHttpClient::async_feature_etraction(const Feature_Etraction_Request *req)
{
	using RESULT = std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<Feature_Etraction_Response>("feature_etraction", srpc::RPCAsyncFutureCallback<Feature_Etraction_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_noise_reduction_task(noise_reductionDone done)
{
	return this->create_rpc_client_task("noise_reduction", std::move(done));
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_feature_etraction_task(feature_etractionDone done)
{
	return this->create_rpc_client_task("feature_etraction", std::move(done));
}

inline BRPCClient::BRPCClient(const char *host, unsigned short port):
	srpc::BRPCClient("SAR_iamge_processing_service")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::BRPCClient::init(&params);
}

inline BRPCClient::BRPCClient(const struct srpc::RPCClientParams *params):
	srpc::BRPCClient("SAR_iamge_processing_service")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::BRPCClient::init(temp);
}

inline void BRPCClient::noise_reduction(const NoiseReduction_Request *req, noise_reductionDone done)
{
	auto *task = this->create_rpc_client_task("noise_reduction", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::noise_reduction(const NoiseReduction_Request *req, NoiseReduction_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_noise_reduction(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<NoiseReduction_Response, srpc::RPCSyncContext>> BRPCClient::async_noise_reduction(const NoiseReduction_Request *req)
{
	using RESULT = std::pair<NoiseReduction_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<NoiseReduction_Response>("noise_reduction", srpc::RPCAsyncFutureCallback<NoiseReduction_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void BRPCClient::feature_etraction(const Feature_Etraction_Request *req, feature_etractionDone done)
{
	auto *task = this->create_rpc_client_task("feature_etraction", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::feature_etraction(const Feature_Etraction_Request *req, Feature_Etraction_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_feature_etraction(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>> BRPCClient::async_feature_etraction(const Feature_Etraction_Request *req)
{
	using RESULT = std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<Feature_Etraction_Response>("feature_etraction", srpc::RPCAsyncFutureCallback<Feature_Etraction_Response>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::BRPCClientTask *BRPCClient::create_noise_reduction_task(noise_reductionDone done)
{
	return this->create_rpc_client_task("noise_reduction", std::move(done));
}

inline srpc::BRPCClientTask *BRPCClient::create_feature_etraction_task(feature_etractionDone done)
{
	return this->create_rpc_client_task("feature_etraction", std::move(done));
}

inline TRPCClient::TRPCClient(const char *host, unsigned short port):
	srpc::TRPCClient("SAR_iamge_processing_service")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::TRPCClient::init(&params);
}

inline TRPCClient::TRPCClient(const struct srpc::RPCClientParams *params):
	srpc::TRPCClient("SAR_iamge_processing_service")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::TRPCClient::init(temp);
}

inline void TRPCClient::noise_reduction(const NoiseReduction_Request *req, noise_reductionDone done)
{
	auto *task = this->create_rpc_client_task("/SAR_iamge_processing_service/noise_reduction", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::noise_reduction(const NoiseReduction_Request *req, NoiseReduction_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_noise_reduction(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<NoiseReduction_Response, srpc::RPCSyncContext>> TRPCClient::async_noise_reduction(const NoiseReduction_Request *req)
{
	using RESULT = std::pair<NoiseReduction_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<NoiseReduction_Response>("/SAR_iamge_processing_service/noise_reduction", srpc::RPCAsyncFutureCallback<NoiseReduction_Response>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCClient::feature_etraction(const Feature_Etraction_Request *req, feature_etractionDone done)
{
	auto *task = this->create_rpc_client_task("/SAR_iamge_processing_service/feature_etraction", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::feature_etraction(const Feature_Etraction_Request *req, Feature_Etraction_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_feature_etraction(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>> TRPCClient::async_feature_etraction(const Feature_Etraction_Request *req)
{
	using RESULT = std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<Feature_Etraction_Response>("/SAR_iamge_processing_service/feature_etraction", srpc::RPCAsyncFutureCallback<Feature_Etraction_Response>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::TRPCClientTask *TRPCClient::create_noise_reduction_task(noise_reductionDone done)
{
	auto *task = this->create_rpc_client_task("/SAR_iamge_processing_service/noise_reduction", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCClientTask *TRPCClient::create_feature_etraction_task(feature_etractionDone done)
{
	auto *task = this->create_rpc_client_task("/SAR_iamge_processing_service/feature_etraction", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline TRPCHttpClient::TRPCHttpClient(const char *host, unsigned short port):
	srpc::TRPCHttpClient("SAR_iamge_processing_service")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::TRPCHttpClient::init(&params);
}

inline TRPCHttpClient::TRPCHttpClient(const struct srpc::RPCClientParams *params):
	srpc::TRPCHttpClient("SAR_iamge_processing_service")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::TRPCHttpClient::init(temp);
}

inline void TRPCHttpClient::noise_reduction(const NoiseReduction_Request *req, noise_reductionDone done)
{
	auto *task = this->create_rpc_client_task("noise_reduction", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::noise_reduction(const NoiseReduction_Request *req, NoiseReduction_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_noise_reduction(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<NoiseReduction_Response, srpc::RPCSyncContext>> TRPCHttpClient::async_noise_reduction(const NoiseReduction_Request *req)
{
	using RESULT = std::pair<NoiseReduction_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<NoiseReduction_Response>("noise_reduction", srpc::RPCAsyncFutureCallback<NoiseReduction_Response>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline void TRPCHttpClient::feature_etraction(const Feature_Etraction_Request *req, feature_etractionDone done)
{
	auto *task = this->create_rpc_client_task("feature_etraction", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::feature_etraction(const Feature_Etraction_Request *req, Feature_Etraction_Response *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_feature_etraction(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>> TRPCHttpClient::async_feature_etraction(const Feature_Etraction_Request *req)
{
	using RESULT = std::pair<Feature_Etraction_Response, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<Feature_Etraction_Response>("feature_etraction", srpc::RPCAsyncFutureCallback<Feature_Etraction_Response>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_noise_reduction_task(noise_reductionDone done)
{
	auto *task = this->create_rpc_client_task("noise_reduction", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_feature_etraction_task(feature_etractionDone done)
{
	auto *task = this->create_rpc_client_task("feature_etraction", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

} // end namespace SAR_iamge_processing_service

